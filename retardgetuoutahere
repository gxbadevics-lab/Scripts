-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

-- Global variables
local totalBucksSpent = 0
local farming_pet_unique, second_farming_pet_unique = nil, nil

-- MISSING FUNCTION PLACEHOLDERS
local function goto_zone(zone)
    print("üìç Would teleport to zone:", zone)
    -- Add your actual zone navigation logic here
end

local function tp_main_map()
    print("üìç Would teleport to main map")
    -- Add your actual teleport logic here
end

local function SendInfoMessage(webhook, message)
    print("üìß Webhook Message:", message)
    -- Add your actual Discord webhook logic here
end

-- Startup Sequence
local function startupChecks()
    print("üîç Starting startup checks...")
    
    -- Wait for game to load completely
    repeat task.wait(1) until game:IsLoaded()
        and game:GetService("ReplicatedStorage"):FindFirstChild("ClientModules")
        and game:GetService("ReplicatedStorage").ClientModules:FindFirstChild("Core")
        and game:GetService("ReplicatedStorage").ClientModules.Core:FindFirstChild("UIManager")
        and game:GetService("ReplicatedStorage").ClientModules.Core.UIManager.Apps:FindFirstChild("TransitionsApp")
        and game.Players.LocalPlayer.PlayerGui:FindFirstChild("TransitionsApp")
        and game.Players.LocalPlayer.PlayerGui.TransitionsApp:FindFirstChild("Whiteout")

    repeat task.wait(1) until game.Players.LocalPlayer.PlayerGui:FindFirstChild("AssetLoadUI")
        and (game.Players.LocalPlayer.PlayerGui.AssetLoadUI.Enabled == false)

    print("[1] Check Done")

    -- Dehash Remotes
    local RS = game:GetService("ReplicatedStorage")
    local RouterClient = require(RS.ClientModules.Core:WaitForChild("RouterClient"):WaitForChild("RouterClient"))
    for name, remote in pairs(getupvalue(RouterClient.init, 7)) do
        remote.Name = name
    end
    print("[Dehash Done]")

    -- Enter Game (choose role, close UI, claim daily)
    local function enter_the_game()
        local args = {
            [1] = "Parents",
            [2] = { ["source_for_logging"] = "intro_sequence" }
        }
        RS.API["TeamAPI/ChooseTeam"]:InvokeServer(unpack(args))

        task.wait(1)
        local ui_stuff = require(RS.Fsys).load("UIManager")
        ui_stuff.set_app_visibility("MainMenuApp", false)
        ui_stuff.set_app_visibility("NewsApp", false)
        ui_stuff.set_app_visibility("DialogApp", false)

        task.wait(3)
        RS.API["DailyLoginAPI/ClaimDailyReward"]:InvokeServer()
        ui_stuff.set_app_visibility("DailyLoginApp", false)
    end
    enter_the_game()

    -- Wait for character
    repeat task.wait() until game:IsLoaded()
        and game.Players.LocalPlayer.Character
        and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")

    print("Final Check Done")
    
    -- Wait 20 seconds before starting recycler
    print("‚è≥ Waiting 20 seconds before starting recycler...")
    task.wait(20)
    print("üöÄ Starting recycler automation...")
end

-- Load required modules after startup
local function loadModules()
    local RouterClient = require(ReplicatedStorage.ClientModules.Core.RouterClient.RouterClient)
    local ClientData = require(ReplicatedStorage.ClientModules.Core.ClientData)
    local PetRecyclerCalculator = require(ReplicatedStorage.new.modules.PetRecycler.PetRecyclerCalculator)
    
    return RouterClient, ClientData, PetRecyclerCalculator
end

-- Utility Functions
local function isBusy(manager)
    local now = os.time()
    if manager.timestamp and manager.timestamp > now then
        return true
    else
        return false
    end
end

local function getReadyTime(manager)
    if not manager.timestamp then
        return "No timestamp found"
    end

    local now = os.time()
    if manager.timestamp <= now then
        return "Rewards are ready to collect!"
    else
        local timeLeft = manager.timestamp - now
        local minutes = math.floor(timeLeft / 60)
        local seconds = timeLeft % 60
        local finishDate = os.date("*t", manager.timestamp)
        local formattedTime = string.format("%02dh%02d", finishDate.hour, finishDate.min)
        return string.format("Rewards ready in %d min %d sec (at %s)", minutes, seconds, formattedTime)
    end
end

local function getFurnitureUnique_recycle_shit()
    local function findFirstChildRecursive(parent, name)
        if not parent then return nil end
        if parent:FindFirstChild(name) then return parent:FindFirstChild(name) end
        for _, child in ipairs(parent:GetChildren()) do
            local found = findFirstChildRecursive(child, name)
            if found then return found end
        end
    end

    local petRecycler = findFirstChildRecursive(workspace.HouseInteriors.furniture, "PetRecycler")
    return petRecycler and petRecycler:GetAttribute("furniture_unique") or nil
end

-- Skip Functions
local function getSkipPrice(ClientData)
    local success, manager = pcall(function()
        return ClientData.get("pet_recycler_manager")
    end)
    if success and manager then
        return manager["skip_price"] or 0
    end
    return 0
end

local function canSkipRecycler(ClientData)
    if not Config.PayToSkip then
        return false
    end
    
    local skipPrice = getSkipPrice(ClientData)
    
    if skipPrice > Config.MaxBucksPerSkip then
        print("‚ùå Skip price too high:", skipPrice, ">", Config.MaxBucksPerSkip)
        return false
    end
    
    local success, playerData = pcall(function()
        return ClientData.get_data()[Players.LocalPlayer.Name]
    end)
    
    if success and playerData and playerData.currency then
        local currentBucks = playerData.currency.bucks or 0
        if currentBucks >= skipPrice then
            return true, skipPrice
        else
            print("‚ùå Not enough bucks. Have:", currentBucks, "Need:", skipPrice)
            return false, skipPrice
        end
    end
    
    return false, skipPrice
end

local function skipRecycler(ClientData)
    local canSkip, skipPrice = canSkipRecycler(ClientData)
    
    if not canSkip then
        return false
    end
    
    local furnitureUnique = getFurnitureUnique_recycle_shit()
    if not furnitureUnique then
        warn("‚ö†Ô∏è Could not find recycler furniture")
        return false
    end
    
    print("‚ö° Attempting to skip recycler for", skipPrice, "bucks...")
    
    local success = pcall(function()
        local args = {
            furnitureUnique,
            "UseBlock",
            {
                action = "skip"
            },
            Players.LocalPlayer.Character
        }
        ReplicatedStorage:WaitForChild("API"):WaitForChild("HousingAPI/ActivateInteriorFurniture"):InvokeServer(unpack(args))
        return true
    end)
    
    if success then
        totalBucksSpent = totalBucksSpent + skipPrice
        print("‚úÖ Successfully skipped recycler for", skipPrice, "bucks. Total spent:", totalBucksSpent)
        
        if Config.RecycleWebhook and Config.RecycleWebhook ~= "" then
            SendInfoMessage(Config.RecycleWebhook, "‚úÖ Skipped recycler for " .. skipPrice .. " bucks. Total spent: " .. totalBucksSpent)
        end
        return true
    else
        print("‚ùå Failed to skip recycler")
        return false
    end
end

-- Recycling Functions
local function get_pet_rarity(kind)
    return "common" -- Placeholder - implement your logic
end

local function try_recycle_5000_point_pets(ClientData, PetRecyclerCalculator)
    if not Config or not Config.AutoReleasePet then 
        warn("‚ö†Ô∏è AutoReleasePet is disabled or Config not found")
        return 
    end
    
    local hasEnabledRarity = false
    for rarity, value in pairs(Config) do
        if (rarity == "common" or rarity == "uncommon" or rarity == "rare" or rarity == "ultra_rare") then
            if value ~= false then
                hasEnabledRarity = true
                break
            end
        end
    end
    
    if not hasEnabledRarity then
        warn("‚ö†Ô∏è No rarity selected")
        return
    end

    local success, playerPets = pcall(function()
        return ClientData.get_data()[Players.LocalPlayer.Name].inventory.pets
    end)
    
    if not success or not playerPets then
        warn("‚ö†Ô∏è Failed to get player pets")
        return
    end

    local chosen, uniques, total, count = {}, {}, 0, 0

    local function shouldRecyclePet(petKind, rarity)
        local configValue = Config[rarity]
        
        if configValue == false then
            return false
        end
        
        if configValue == true or configValue == "all" then
            return true
        end
        
        if type(configValue) == "table" then
            for _, allowedKind in ipairs(configValue) do
                if string.lower(tostring(petKind)) == string.lower(tostring(allowedKind)) then
                    return true
                end
            end
            return false
        end
        
        return false
    end

    for _, pet in pairs(playerPets) do
        -- FIXED: Changed pet.unique ~= "practice_dog" to pet.kind ~= "practice_dog"
        if pet and pet.unique and pet.kind ~= "practice_dog" and not string.match(pet.kind or "", "_egg$") then
            -- FIXED: Replaced 'continue' with proper Lua syntax
            if pet.unique == farming_pet_unique or pet.unique == second_farming_pet_unique then
                -- Skip to next iteration (equivalent to continue)
                goto continue
            end
            
            local rarity = get_pet_rarity(pet.kind)
            if rarity and shouldRecyclePet(pet.kind, rarity) then
                local success2, value = pcall(function()
                    return PetRecyclerCalculator.get_pet_value(pet)
                end)
                
                if success2 and value then
                    local unique = tostring(pet.unique)
                    table.insert(chosen, {kind=pet.kind, rarity=rarity, unique=unique, value=value})
                    uniques[unique] = true
                    total, count = total + value, count + 1
                    if count >= 60 then break end
                else
                    print("‚ö†Ô∏è Skipping pet - can't calculate value:", pet.kind)
                end
            end
        end
        ::continue::
    end

    if #chosen == 0 then 
        warn("‚ö†Ô∏è No valid pets found for recycling")
        return 
    end

    if total >= 5000 then
        local success3 = pcall(function()
            local args = {"Nursery"}
            ReplicatedStorage:WaitForChild("API"):WaitForChild("LocationAPI/SetLocation"):FireServer(unpack(args))
        end)
        
        if not success3 then
            warn("‚ö†Ô∏è Failed to teleport to Nursery")
            return
        end
        
        task.wait(3)
        print("‚ôªÔ∏è Recycling with", total, "points | Pets:", #chosen)
        
        if Config.RecycleWebhook and Config.RecycleWebhook ~= "" then
            SendInfoMessage(Config.RecycleWebhook, "‚ôªÔ∏è Recycling Pets: Total Points: " .. total .. " Pets Count: " .. #chosen)
        end
        
        local furnitureUnique = getFurnitureUnique_recycle_shit()
        if furnitureUnique then
            pcall(function()
                ReplicatedStorage.API["HousingAPI/ActivateInteriorFurniture"]:InvokeServer(
                    furnitureUnique, 
                    "UseBlock", 
                    {action="use", uniques=uniques}, 
                    Players.LocalPlayer.Character
                )
            end)
        else
            warn("‚ö†Ô∏è Could not find recycler furniture")
        end
    else
        print("‚ùå Not enough points:", total, "/ 5000")
        if Config.RecycleWebhook and Config.RecycleWebhook ~= "" then
            SendInfoMessage(Config.RecycleWebhook, "‚ùå Not enough points: " .. total .. "/ 5000")
        end
    end
end

local function check_if_enough_point(ClientData)
    local nigga = ClientData.get("pet_recycler_manager")["saved_points"]
    if nigga >= 5000 then
        print("enough point for crystal egg, total point : " .. nigga)
        if Config.RecycleWebhook and Config.RecycleWebhook ~= "" then
            SendInfoMessage(Config.RecycleWebhook, "enough point for crystal egg, total point : " .. nigga)
        end
        local args = {"Nursery"}
        ReplicatedStorage:WaitForChild("API"):WaitForChild("LocationAPI/SetLocation"):FireServer(unpack(args))
        task.wait(3)
        local Recycle_unique = getFurnitureUnique_recycle_shit()
        local args = {
            Recycle_unique,
            "UseBlock",
            {
                action = "use",
                uniques = {}
            },
            Players.LocalPlayer.Character
        }
        ReplicatedStorage:WaitForChild("API"):WaitForChild("HousingAPI/ActivateInteriorFurniture"):InvokeServer(unpack(args))
    else
        print("poor nigga")
        try_recycle_5000_point_pets(ClientData, PetRecyclerCalculator)
    end
end

local function search_recycle_quest(ClientData)
    local quests = ClientData.get("quest_manager")["quests_cached"]
    for id, data in pairs(quests) do
        local name = data.entry_name
        if name == "pet_recycler_reward_ready" then
            pcall(function()
                goto_zone("Main")
                task.wait(1)
                local args = {"Nursery"}
                ReplicatedStorage:WaitForChild("API"):WaitForChild("LocationAPI/SetLocation"):FireServer(unpack(args))
                task.wait(3)
                local Recycle_unique = getFurnitureUnique_recycle_shit()
                task.wait(1)
                local args = {
                    Recycle_unique,
                    "UseBlock",
                    {
                        action = "claim"
                    },
                    Players.LocalPlayer.Character
                }
                ReplicatedStorage:WaitForChild("API"):WaitForChild("HousingAPI/ActivateInteriorFurniture"):InvokeServer(unpack(args))
                print("claiming recycle reward")
                if Config.RecycleWebhook and Config.RecycleWebhook ~= "" then
                    SendInfoMessage(Config.RecycleWebhook, "claiming recycle reward")
                end
            end)
        end
    end
end

-- Main Logic
local function main_logic_recycle_shit(ClientData)
    local recyclerManager = ClientData.get("pet_recycler_manager")
    
    if isBusy(recyclerManager) then
        print("Recycler is busy...")
        print(getReadyTime(recyclerManager))
        
        local currentSkipPrice = getSkipPrice(ClientData)
        print("üí∞ Current skip price:", currentSkipPrice, "bucks")
        
        if Config.PayToSkip then
            skipRecycler(ClientData)
        end
        
        if Config.RecycleWebhook and Config.RecycleWebhook ~= "" then
            SendInfoMessage(Config.RecycleWebhook, getReadyTime(recyclerManager) .. " | Skip price: " .. currentSkipPrice .. " bucks")
        end
    else
        print("Recycler is idle!")
        search_recycle_quest(ClientData)
        task.wait(1)
        check_if_enough_point(ClientData)
        
        if isBusy(recyclerManager) then
            print("Recycler is now busy after recycling...")
            print(getReadyTime(recyclerManager))
            
            if Config.PayToSkip then
                skipRecycler(ClientData)
            end
        end
        task.wait(1)
        tp_main_map()
    end
end

-- Main Execution Function
local function startRecyclerAutomation()
    -- Step 1: Run startup sequence (includes 20 second wait)
    startupChecks()
    
    -- Step 2: Load required modules
    local RouterClient, ClientData, PetRecyclerCalculator = loadModules()
    
    -- Step 3: Start the main recycler loop
    while true do
        local success, err = pcall(function()
            main_logic_recycle_shit(ClientData)
        end)
        
        if not success then
            warn("‚ùå Error in recycler automation:", err)
        end
        
        print("üîÑ Waiting 60 seconds before next check...")
        task.wait(60) -- Wait 1 minute before next cycle
    end
end

-- Start the automation
startRecyclerAutomation()
