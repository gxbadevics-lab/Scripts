-- full_hotdog_buyer.lua
-- Expects an external config (not obfuscated) like:
-- HOTDOG_CONFIG = { seller = "m4alt_1", price = 50 }

-- === Internal constants ===
local TOTAL_SPEND_PER_CYCLE = 150      -- internal: how much to spend each cycle (in bucks)
local MIN_HUMAN_PAUSE = 10             -- seconds between individual buys
local MAX_HUMAN_PAUSE = 15
local CYCLE_BASE_WAIT = 120            -- base wait after a cycle (seconds)
local CYCLE_JITTER_MAX = 15            -- additional random jitter (seconds)

-- === Validate external config ===
if type(HOTDOG_CONFIG) ~= "table" then
    error("HOTDOG_CONFIG missing. Define HOTDOG_CONFIG = { seller = 'name', price = 50 } before running.")
end
local SELLER_NAME = tostring(HOTDOG_CONFIG.seller or "")
local UNIT_PRICE = tonumber(HOTDOG_CONFIG.price or HOTDOG_CONFIG.unitPrice)
if SELLER_NAME == "" or not UNIT_PRICE or UNIT_PRICE <= 0 then
    error("Invalid HOTDOG_CONFIG. seller must be username, price must be > 0.")
end

-- === Utilities ===
math.randomseed(tick() % 2^31)
local function humanPause()
    local ms = math.random(math.floor(MIN_HUMAN_PAUSE*1000), math.floor(MAX_HUMAN_PAUSE*1000)) / 1000
    task.wait(ms)
end
local function tinyPause()
    task.wait(0.6 + (math.random() * 0.6))
end

-- === Startup checks (UI/assets/players) ===
repeat task.wait(1) until game:IsLoaded()
    and game:GetService("ReplicatedStorage"):FindFirstChild("ClientModules")
    and game.Players.LocalPlayer

repeat task.wait(.5) until game.Players.LocalPlayer.PlayerGui and game.Players.LocalPlayer.PlayerGui:FindFirstChild("TransitionsApp") and game.Players.LocalPlayer.PlayerGui.TransitionsApp:FindFirstChild("Whiteout") or true
repeat task.wait(.5) until game.Players.LocalPlayer.PlayerGui:FindFirstChild("AssetLoadUI") == nil or (game.Players.LocalPlayer.PlayerGui.AssetLoadUI.Enabled == false) or true

print("[Loader] Basic checks done")

-- === Attempt safe dehash (non-fatal) ===
pcall(function()
    local RS = game:GetService("ReplicatedStorage")
    local ok, RouterClient = pcall(function()
        return require(RS.ClientModules.Core:WaitForChild("RouterClient"):WaitForChild("RouterClient"))
    end)
    if ok and type(RouterClient) == "table" then
        local success, remoteMap = pcall(function() return getupvalue(RouterClient.init, 7) end)
        if success and type(remoteMap) == "table" then
            for name, remote in pairs(remoteMap) do
                pcall(function() remote.Name = name end)
            end
            print("[Loader] Dehash complete")
        else
            warn("[Loader] Dehash: remote map not found")
        end
    end
end)

-- === Try to auto-enter (choose team / close UI / claim daily) - non-fatal ===
pcall(function()
    local RS = game:GetService("ReplicatedStorage")
    if RS:FindFirstChild("API") and RS.API:FindFirstChild("TeamAPI/ChooseTeam") then
        local args = { [1] = "Parents", [2] = { ["source_for_logging"] = "intro_sequence" } }
        pcall(function() RS.API["TeamAPI/ChooseTeam"]:InvokeServer(unpack(args)) end)
    end

    task.wait(1)
    if pcall(function() return RS.Fsys end) then
        local ok, ui = pcall(function() return require(RS.Fsys).load("UIManager") end)
        if ok and ui then
            pcall(function() ui.set_app_visibility("MainMenuApp", false) end)
            pcall(function() ui.set_app_visibility("NewsApp", false) end)
            pcall(function() ui.set_app_visibility("DialogApp", false) end)
            task.wait(2)
            if RS.API and RS.API:FindFirstChild("DailyLoginAPI/ClaimDailyReward") then
                pcall(function() RS.API["DailyLoginAPI/ClaimDailyReward"]:InvokeServer() end)
                pcall(function() ui.set_app_visibility("DailyLoginApp", false) end)
            end
        end
    end
end)

-- === Wait for character spawn (ensure LocalPlayer exists and has HRP) ===
repeat task.wait() until game.Players.LocalPlayer and game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
print("[Loader] Character ready")

-- === Money reader function (uses provided ClientData method) ===
local function getBucks()
    local ok, val = pcall(function()
        return tonumber(require(game.ReplicatedStorage:WaitForChild("ClientModules").Core.ClientData).get("money"))
    end)
    if not ok then
        warn("[Money] Failed to read money; returning 0")
        return 0
    end
    return val or 0
end

-- === Buy remote getter (retries if missing) ===
local function getBuyRemote()
    local RS = game:GetService("ReplicatedStorage")
    if not RS:FindFirstChild("API") then return nil end
    local API = RS:WaitForChild("API")
    if API:FindFirstChild("PlaceableToolAPI/BuyRefreshment") then
        return API:WaitForChild("PlaceableToolAPI/BuyRefreshment")
    end
    return nil
end

-- === Main buy loop ===
task.spawn(function()
    local BUY_REMOTE = getBuyRemote()

    while true do
        local cycleSpent = 0
        local maxBuysThisCycle = math.floor(TOTAL_SPEND_PER_CYCLE / UNIT_PRICE)
        print(string.format("[Cycle] Starting. Target up to %d buys (unit=%d, targetSpend=%d)", maxBuysThisCycle, UNIT_PRICE, TOTAL_SPEND_PER_CYCLE))

        while cycleSpent < TOTAL_SPEND_PER_CYCLE do
            -- Check money
            local bucks = getBucks()
            if bucks < UNIT_PRICE then
                print("[Cycle] Not enough bucks for another buy. Bucks:", bucks)
                break
            end

            -- Ensure buy remote available (try to reacquire)
            if not BUY_REMOTE then
                BUY_REMOTE = getBuyRemote()
                if not BUY_REMOTE then
                    warn("[Buy] BuyRefreshment remote not found; aborting buys this cycle")
                    break
                end
            end

            -- Ensure seller exists in Players
            local players = game:GetService("Players")
            local sellerPlayer = players:FindFirstChild(SELLER_NAME)
            if not sellerPlayer then
                -- Wait briefly for player to appear; if still not found skip this buy attempt
                sellerPlayer = players:FindFirstChild(SELLER_NAME) or players:WaitForChild(SELLER_NAME, 2)
                if not sellerPlayer then
                    warn("[Buy] Seller '" .. SELLER_NAME .. "' not found in server. Aborting cycle.")
                    break
                end
            end

            -- Perform buy in pcall
            local success, err = pcall(function()
                local args = {
                    [1] = "hotdog_stand",
                    [2] = sellerPlayer,
                    [3] = UNIT_PRICE
                }
                BUY_REMOTE:InvokeServer(unpack(args))
            end)

            if not success then
                warn("[Buy] InvokeServer failed:", err)
                -- small backoff before retrying to avoid spam
                tinyPause()
            else
                cycleSpent = cycleSpent + UNIT_PRICE
                print(string.format("[Buy] Bought one. CycleSpent=%d. Bucks (approx) after buy: %s", cycleSpent, tostring(getBucks())))
            end

            -- human pause between individual purchases (10-15s)
            humanPause()

            -- safety check if we've reached theoretical max buys
            if cycleSpent >= TOTAL_SPEND_PER_CYCLE then break end
        end

        if cycleSpent == 0 then
            print("[Cycle] No purchases made this cycle (not enough funds or missing remote/seller).")
        else
            print(string.format("[Cycle] Completed. Spent approximately %d this cycle.", cycleSpent))
        end

        -- Wait ~2 minutes + jitter before next cycle
        local jitter = math.random(0, CYCLE_JITTER_MAX)
        local waitTime = CYCLE_BASE_WAIT + jitter
        print("[Cycle] Waiting " .. tostring(waitTime) .. " seconds until next cycle.")
        task.wait(waitTime)
    end
end)
