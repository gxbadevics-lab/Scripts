

if type(HOTDOG_CONFIG) ~= "table" then
    error("HOTDOG_CONFIG missing. Define HOTDOG_CONFIG = { seller = 'name', price = 50 } before running this script.")
end
local SELLER_NAME = tostring(HOTDOG_CONFIG.seller or "")
local UNIT_PRICE   = tonumber(HOTDOG_CONFIG.price or 0)
if SELLER_NAME == "" or UNIT_PRICE <= 0 then
    error("Invalid HOTDOG_CONFIG values. seller must be a username and price must be > 0.")
end


math.randomseed(tick() % 2147483647)
local function humanPause()
    -- internal human-like delay (kept inside main so can be obfuscated)
    local low, high = 0.8, 2.3
    task.wait(math.random( math.floor(low*100), math.floor(high*100) ) / 100)
end


repeat task.wait(1) until game:IsLoaded()
    and game:GetService("ReplicatedStorage"):FindFirstChild("ClientModules")
    and game:GetService("ReplicatedStorage").ClientModules:FindFirstChild("Core")
    and game:GetService("ReplicatedStorage").ClientModules.Core:FindFirstChild("UIManager")
    and game.Players.LocalPlayer.PlayerGui:FindFirstChild("TransitionsApp")
    and game.Players.LocalPlayer.PlayerGui.TransitionsApp:FindFirstChild("Whiteout")

repeat task.wait(1) until game.Players.LocalPlayer.PlayerGui:FindFirstChild("AssetLoadUI")
    and (game.Players.LocalPlayer.PlayerGui.AssetLoadUI.Enabled == false)

print("[Loader] Basic UI checks passed")


local RS = game:GetService("ReplicatedStorage")
local ok, RouterClient = pcall(function()
    return require(RS.ClientModules.Core:WaitForChild("RouterClient"):WaitForChild("RouterClient"))
end)

if ok and type(RouterClient) == "table" then
    local remoteMap = nil
    pcall(function()
        remoteMap = getupvalue(RouterClient.init, 7)
    end)
    if type(remoteMap) == "table" then
        for name, remote in pairs(remoteMap) do
            -- protect with pcall in case of readonly
            pcall(function() remote.Name = name end)
        end
        print("[Loader] Dehash complete")
    else
        warn("[Loader] Dehash: remote map not found (continuing anyway)")
    end
else
    warn("[Loader] RouterClient require failed (continuing anyway)")
end


pcall(function()
    if RS:FindFirstChild("API") and RS.API:FindFirstChild("TeamAPI/ChooseTeam") then
        local args = { [1] = "Parents", [2] = { ["source_for_logging"] = "intro_sequence" } }
        pcall(function() RS.API["TeamAPI/ChooseTeam"]:InvokeServer(unpack(args)) end)
    end

    task.wait(1)
    if pcall(function() return RS.Fsys end) then
        local success, ui = pcall(function() return require(RS.Fsys).load("UIManager") end)
        if success and ui then
            pcall(function() ui.set_app_visibility("MainMenuApp", false) end)
            pcall(function() ui.set_app_visibility("NewsApp", false) end)
            pcall(function() ui.set_app_visibility("DialogApp", false) end)
            task.wait(2)
            if RS.API and RS.API:FindFirstChild("DailyLoginAPI/ClaimDailyReward") then
                pcall(function() RS.API["DailyLoginAPI/ClaimDailyReward"]:InvokeServer() end)
                pcall(function() ui.set_app_visibility("DailyLoginApp", false) end)
            end
        end
    end
end)


repeat task.wait() until game.Players.LocalPlayer and game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
print("[Loader] Character ready")


local function getBucks()
    local ok, value = pcall(function()
        return tonumber(require(game.ReplicatedStorage:WaitForChild("ClientModules").Core.ClientData).get("money"))
    end)
    if not ok then
        warn("[Money] Failed to read money via ClientData; returning 0")
        return 0
    end
    return value or 0
end



local function getBuyRemote()
    if RS:FindFirstChild("API") then
        local API = RS:WaitForChild("API")
        if API:FindFirstChild("PlaceableToolAPI/BuyRefreshment") then
            return API:WaitForChild("PlaceableToolAPI/BuyRefreshment")
        end
    end
    return nil
end

local BUY_REMOTE = getBuyRemote()
if not BUY_REMOTE then
    warn("[Buy] BuyRefreshment remote not found. Script will attempt again at runtime.")
end


task.spawn(function()
    while true do
        -- buy until you cannot afford another unit
        local boughtThisCycle = 0
        while true do
            local bucks = getBucks()
            if bucks < UNIT_PRICE then
                -- not enough to buy a single unit: stop inner loop
                break
            end


            if not BUY_REMOTE then
                BUY_REMOTE = getBuyRemote()
                if not BUY_REMOTE then
                    warn("[Buy] buy remote missing; aborting buying for this cycle")
                    break
                end
            end

            local success, err = pcall(function()
                -- build args exactly as provided earlier
                local args = {
                    [1] = "hotdog_stand",
                    [2] = game:GetService("Players"):WaitForChild(SELLER_NAME),
                    [3] = UNIT_PRICE
                }
                BUY_REMOTE:InvokeServer(unpack(args))
            end)

            if not success then
                warn("[Buy] failed to InvokeServer:", err)
                -- if remote fails, small pause then retry
                task.wait(1.2)
            else
                boughtThisCycle = boughtThisCycle + 1
                print(string.format("[Buy] bought #%d this cycle. Spent %d (unit=%d). Bucks left (approx): %s", boughtThisCycle, boughtThisCycle*UNIT_PRICE, UNIT_PRICE, tostring(getBucks())))
            end

            humanPause()
        end

        if boughtThisCycle == 0 then
            print("[Buy] No purchases made this cycle (not enough funds or remote missing)")
        else
            print(string.format("[Buy] Cycle complete: bought %d items", boughtThisCycle))
        end

        -- wait about 2 minutes before trying again, with a small random jitter
        local base = 120
        local jitter = math.random(0, 20) -- 0-20s jitter
        local waitTime = base + jitter
        print("[Buy] Waiting approximately "..waitTime.." seconds before next cycle")
        task.wait(waitTime)
    end
end)
